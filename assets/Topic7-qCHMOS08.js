import{j as e}from"./index-meFSU1Lv.js";import{E as i}from"./EditableCCodeBlock-C1aLYO6_.js";const n=`#include <stdio.h>\r
\r
int main() {\r
    int arr[5] = {10, 20, 30, 40, 50};\r
    int *ptr = arr;  // ptr points to first element\r
\r
    // Access using array indexing\r
    printf("Using array indexing:\\n");\r
    for (int i = 0; i < 5; i++) {\r
        printf("arr[%d] = %d\\n", i, arr[i]);\r
    }\r
\r
    // Access using pointer arithmetic\r
    printf("\\nUsing pointer arithmetic:\\n");\r
    for (int i = 0; i < 5; i++) {\r
        printf("*(ptr + %d) = %d\\n", i, *(ptr + i));\r
    }\r
\r
    // Show equivalence: arr[2] vs *(arr+2)\r
    printf("\\narr[2] = %d, *(arr+2) = %d\\n", arr[2], *(arr + 2));\r
\r
    return 0;\r
}`,s=`#include <stdio.h>\r
\r
int main() {\r
    int arr[5] = {2, 4, 6, 8, 10};\r
    int *ptr = arr;\r
\r
    // Traverse using pointer increment\r
    printf("Traversing with ptr++:\\n");\r
    for (int i = 0; i < 5; i++) {\r
        printf("Current element: %d, address: %p\\n", *ptr, (void*)ptr);\r
        ptr++;  // move to next element (scales by sizeof(int))\r
    }\r
\r
    // After loop, ptr points one past the end\r
    printf("\\nAfter loop, ptr points to: %p\\n", (void*)ptr);\r
\r
    // Reset pointer\r
    ptr = arr;\r
    printf("\\nFirst element again: %d\\n", *ptr);\r
\r
    return 0;\r
}`,a=`#include <stdio.h>\r
\r
int main() {\r
    int arr[5] = {10, 20, 30, 40, 50};\r
    int *ptr1 = &arr[1];  // points to 20\r
    int *ptr2 = &arr[4];  // points to 50\r
\r
    // Subtracting pointers gives number of elements between them\r
    ptrdiff_t diff = ptr2 - ptr1;\r
    printf("ptr2 - ptr1 = %td (elements between)\\n", diff);\r
    printf("ptr2 points to %d, ptr1 points to %d\\n", *ptr2, *ptr1);\r
\r
    // Using pointer subtraction to find index\r
    int *start = arr;\r
    int index = ptr1 - start;\r
    printf("ptr1 is at index %d\\n", index);\r
\r
    return 0;\r
}`,d=`
  @keyframes fade-slide-up {
    0% { opacity: 0; transform: translateY(20px); }
    100% { opacity: 1; transform: translateY(0); }
  }
`,h=()=>{const t=new Date().getFullYear()-1998;return e.jsxs("div",{className:"dark",style:{backgroundColor:"#121212"},children:[" ",e.jsx("style",{children:d}),e.jsxs("div",{className:"max-w-4xl mx-auto p-6 space-y-8 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300",children:[e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate",children:[e.jsx("h1",{className:"text-4xl font-light tracking-tight leading-tight",children:"Topic 7: Pointer arithmetic and its relation to array indexing"}),e.jsxs("p",{className:"text-lg text-gray-600 dark:text-gray-400 mt-2 leading-relaxed",children:["How C connects pointers and arrays ‚Äì and why ",e.jsx("code",{children:"arr[i]"})," is just syntactic sugar for ",e.jsx("code",{children:"*(arr + i)"}),"."]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[100ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üîó Pointer arithmetic defined"}),e.jsxs("p",{className:"leading-relaxed",children:["In C, when you add an integer to a pointer, the compiler automatically scales the addition by the size of the pointed-to type. For example, if ",e.jsx("code",{children:"ptr"})," is an ",e.jsx("code",{children:"int*"})," and ",e.jsx("code",{children:"sizeof(int) == 4"}),", then ",e.jsx("code",{children:"ptr + 1"})," advances the address by 4 bytes, not 1 byte. This scaling is what makes array indexing work."]}),e.jsxs("p",{className:"leading-relaxed mt-4",children:["The expression ",e.jsx("code",{children:"arr[i]"})," is exactly equivalent to ",e.jsx("code",{children:"*(arr + i)"}),". The array name ",e.jsx("code",{children:"arr"})," decays to a pointer to the first element. Adding ",e.jsx("code",{children:"i"})," gives the address of the i‚Äëth element, and dereferencing retrieves the value. This is why array indices start at 0: ",e.jsx("code",{children:"arr + 0"})," points to the first element."]}),e.jsxs("div",{className:"mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 rounded",children:[e.jsx("p",{className:"text-sm font-medium",children:"üè´ Real‚Äëworld analogy:"}),e.jsxs("p",{className:"text-sm mt-1",children:["At ",e.jsx("strong",{children:"Barrackpore CNAT"}),", if the lockers are numbered 0,1,2,‚Ä¶ and each locker occupies 1 meter of wall space, then the address of locker ",e.jsx("code",{children:"i"})," is base address + i meters. Pointer arithmetic works the same way: ",e.jsx("code",{children:"ptr + i"})," moves i lockers forward, automatically accounting for locker width."]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[200ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üßÆ Visualizing pointer arithmetic"}),e.jsx("div",{className:"flex justify-center p-4 bg-gray-100 dark:bg-gray-800 rounded-xl transition-all duration-300 hover:shadow-xl",children:e.jsxs("svg",{width:"450",height:"200",viewBox:"0 0 450 200",className:"max-w-full h-auto",children:[[0,1,2,3,4].map(r=>e.jsxs("g",{children:[e.jsx("rect",{x:30+r*70,y:"50",width:"60",height:"50",fill:"none",stroke:"#3b82f6",strokeWidth:"2",rx:"2"}),e.jsxs("text",{x:30+r*70+30,y:"85",textAnchor:"middle",fill:"currentColor",children:["arr[",r,"]"]}),e.jsxs("text",{x:30+r*70+30,y:"110",textAnchor:"middle",fill:"#6b7280",className:"text-xs",children:["0x",(1e3+r*4).toString(16)]})]},r)),e.jsx("line",{x1:"100",y1:"30",x2:"170",y2:"45",stroke:"#ef4444",strokeWidth:"2",markerEnd:"url(#arrow)"}),e.jsx("text",{x:"70",y:"25",fill:"#ef4444",fontSize:"12",children:"ptr = arr"}),e.jsx("text",{x:"180",y:"25",fill:"#ef4444",fontSize:"12",children:"ptr+2"}),e.jsx("defs",{children:e.jsx("marker",{id:"arrow",markerWidth:"10",markerHeight:"10",refX:"9",refY:"5",orient:"auto",children:e.jsx("path",{d:"M0,0 L10,5 L0,10 Z",fill:"#ef4444"})})})]})}),e.jsxs("p",{className:"text-sm text-gray-600 dark:text-gray-400 mt-2 text-center",children:[e.jsx("code",{children:"ptr + 2"})," moves two elements forward; ",e.jsx("code",{children:"*(ptr+2)"})," is the same as ",e.jsx("code",{children:"arr[2]"}),"."]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[300ms] space-y-6",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üíª Pointer arithmetic in C"}),e.jsx(i,{title:"Example 1: Array indexing vs pointer arithmetic",initialCode:n}),e.jsx("p",{className:"text-sm text-gray-600 dark:text-gray-400 -mt-2",children:"Both forms produce identical machine code."}),e.jsx(i,{title:"Example 2: Pointer increment and traversal",initialCode:s}),e.jsx(i,{title:"Example 3: Subtracting pointers (distance between elements)",initialCode:a})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[400ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üí° Tips & Tricks (Professional habits)"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 leading-relaxed",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Use array indexing for readability"})," ‚Äì ",e.jsx("code",{children:"arr[i]"})," is clearer than ",e.jsx("code",{children:"*(arr + i)"})," in most cases."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Pointer arithmetic is essential when working with dynamically allocated memory"})," ‚Äì e.g., ",e.jsx("code",{children:"malloc"})," returns a pointer, and you navigate with ",e.jsx("code",{children:"ptr + i"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"You can increment a pointer variable"})," (",e.jsx("code",{children:"ptr++"}),") but not the array name itself (",e.jsx("code",{children:"arr++"})," is invalid)."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Pointer subtraction gives the number of elements between two pointers"})," ‚Äì useful for calculating indices."]}),e.jsxs("li",{children:[e.jsxs("strong",{children:["Be careful with pointer arithmetic on ",e.jsx("code",{children:"void*"})]})," ‚Äì not allowed in standard C; cast to ",e.jsx("code",{children:"char*"})," first for byte‚Äëlevel operations."]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[500ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"‚ö†Ô∏è Common Pitfalls (Beginner traps)"}),e.jsxs("div",{className:"space-y-3",children:[e.jsxs("div",{className:"p-3 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded",children:[e.jsx("p",{className:"font-medium",children:"Forgetting that pointer arithmetic scales by type size"}),e.jsxs("p",{className:"text-sm",children:[e.jsx("code",{children:"char *cptr; int *iptr; cptr + 1"})," moves 1 byte, ",e.jsx("code",{children:"iptr + 1"})," moves 4 (or more). Beginners sometimes think it always moves 1 byte."]})]}),e.jsxs("div",{className:"p-3 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded",children:[e.jsx("p",{className:"font-medium",children:"Applying pointer arithmetic to a pointer that doesn't point to an array"}),e.jsx("p",{className:"text-sm",children:"Adding to a pointer that points to a single variable leads to undefined behavior if dereferenced."})]}),e.jsxs("div",{className:"p-3 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded",children:[e.jsxs("p",{className:"font-medium",children:["Misunderstanding ",e.jsx("code",{children:"&arr"})," vs ",e.jsx("code",{children:"arr"})]}),e.jsxs("p",{className:"text-sm",children:[e.jsx("code",{children:"&arr"})," is a pointer to the whole array (type ",e.jsx("code",{children:"int (*)[5]"}),"). ",e.jsx("code",{children:"&arr + 1"})," jumps by the entire array size, not one element."]})]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[600ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"‚úÖ Best Practices (Write clean, safe code)"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[e.jsx("li",{children:"When using pointer arithmetic for iteration, ensure you don't go out of bounds."}),e.jsxs("li",{children:["Use ",e.jsx("code",{children:"const"})," with pointers to prevent unintended modification: ",e.jsx("code",{children:"const int *ptr"}),"."]}),e.jsxs("li",{children:["If you need byte‚Äëlevel access, cast to ",e.jsx("code",{children:"char*"})," and work with bytes."]}),e.jsx("li",{children:"Document complex pointer arithmetic with comments ‚Äì it can be hard to read."}),e.jsx("li",{children:"Prefer array indexing for clarity unless performance measurements show pointer arithmetic is faster (usually they are identical)."})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[700ms] p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded",children:[e.jsx("h2",{className:"text-xl font-medium mb-2",children:"üìã Mini Checklist ‚Äì What to remember"}),e.jsxs("ul",{className:"list-check list-inside space-y-1",children:[e.jsxs("li",{children:["‚úîÔ∏è ",e.jsx("code",{children:"arr[i] ‚â° *(arr + i)"}),"."]}),e.jsxs("li",{children:["‚úîÔ∏è Pointer arithmetic scales by ",e.jsx("code",{children:"sizeof(type)"}),"."]}),e.jsx("li",{children:"‚úîÔ∏è You can increment/decrement pointer variables, not array names."}),e.jsx("li",{children:"‚úîÔ∏è Subtracting pointers gives the number of elements between them."}),e.jsx("li",{children:"‚úîÔ∏è Dereferencing a pointer out of bounds is undefined behavior."})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[800ms] p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded",children:[e.jsx("h2",{className:"text-xl font-medium mb-2",children:"ü§î Hint ‚Äì Think like a programmer"}),e.jsxs("p",{className:"italic",children:["‚ÄúIn Example 1, try changing ",e.jsx("code",{children:"*(ptr + i)"})," to ",e.jsx("code",{children:"*ptr + i"}),". What happens? (Hint: operator precedence.)‚Äù"]}),e.jsxs("p",{className:"italic mt-2",children:["‚ÄúIf ",e.jsx("code",{children:"ptr"})," points to ",e.jsx("code",{children:"arr[2]"}),", what does ",e.jsx("code",{children:"ptr[-1]"})," give? Yes, negative indices are allowed as long as they stay within array bounds.‚Äù"]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[900ms] p-6 bg-purple-50 dark:bg-purple-900/20 border-l-4 border-purple-500 rounded transition-all duration-300 hover:shadow-lg",children:[e.jsx("h2",{className:"text-xl font-medium mb-2",children:"üßë‚Äçüè´ Teacher's Note ‚Äì Sukanta Hui"}),e.jsxs("div",{className:"space-y-2 text-sm",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Sukanta Hui"})," (email: ",e.jsx("a",{href:"mailto:sukantahui@codernaccotax.co.in",className:"underline",children:"sukantahui@codernaccotax.co.in"}),", mobile: 7003756860) has been teaching programming for ",e.jsxs("strong",{children:[t," years"]})," (since 1998). His expertise spans Programming Languages, RDBMS, Operating Systems, and Web Development."]}),e.jsxs("p",{className:"mt-2",children:["üí¨ ‚ÄúAt ",e.jsx("strong",{children:"Naihati CNAT"}),", I show students: ",e.jsx("code",{children:"arr[2]"})," is just a convenient way to write ",e.jsx("code",{children:"*(arr+2)"}),". Once they understand that, pointer arithmetic becomes intuitive. I also warn them: ",e.jsx("code",{children:"arr"})," is like a street address ‚Äì you can't change it, but you can walk along it.‚Äù"]}),e.jsxs("p",{className:"mt-2",children:["üîç ",e.jsx("strong",{children:"Point to remember:"})," The equivalence between arrays and pointers is fundamental in C. Mastering pointer arithmetic opens the door to dynamic memory and low‚Äëlevel programming."]})]})]})]})]})};export{h as default};
