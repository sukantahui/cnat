import{j as e}from"./index-meFSU1Lv.js";import{E as r}from"./EditableCCodeBlock-C1aLYO6_.js";const i=`#include <stdio.h>\r
\r
int main() {\r
    int arr[5] = {10, 20, 30, 40, 50};\r
\r
    printf("Array elements and their addresses:\\n");\r
    for (int i = 0; i < 5; i++) {\r
        printf("arr[%d] = %d\\t address: %p\\n", i, arr[i], (void*)&arr[i]);\r
    }\r
\r
    // Show the difference between consecutive addresses\r
    printf("\\nSize of int on this system: %zu bytes\\n", sizeof(int));\r
    printf("Address of arr[0]: %p\\n", (void*)&arr[0]);\r
    printf("Address of arr[1]: %p\\n", (void*)&arr[1]);\r
    printf("Difference: %ld bytes\\n", (char*)&arr[1] - (char*)&arr[0]);\r
\r
    return 0;\r
}`,n=`#include <stdio.h>\r
\r
int main() {\r
    int arr[5] = {10, 20, 30, 40, 50};\r
    int *ptr = arr;  // ptr points to first element\r
\r
    printf("Using array indexing:\\n");\r
    for (int i = 0; i < 5; i++) {\r
        printf("arr[%d] = %d\\n", i, arr[i]);\r
    }\r
\r
    printf("\\nUsing pointer arithmetic:\\n");\r
    for (int i = 0; i < 5; i++) {\r
        printf("*(ptr + %d) = %d\\n", i, *(ptr + i));\r
    }\r
\r
    // Show that ptr + i gives the address of arr[i]\r
    printf("\\nAddresses:\\n");\r
    printf("ptr + 2 = %p, &arr[2] = %p\\n", (void*)(ptr + 2), (void*)&arr[2]);\r
\r
    return 0;\r
}`,o=`#include <stdio.h>\r
\r
int main() {\r
    int arr[5] = {2, 4, 6, 8, 10};\r
\r
    // Array name 'arr' is a pointer to the first element\r
    printf("arr = %p, &arr[0] = %p\\n", (void*)arr, (void*)&arr[0]);\r
\r
    // arr + 1 gives address of second element\r
    printf("arr + 1 = %p, &arr[1] = %p\\n", (void*)(arr + 1), (void*)&arr[1]);\r
\r
    // sizeof works on the whole array only in this scope\r
    printf("Size of whole array: %zu bytes\\n", sizeof(arr));\r
    printf("Number of elements: %zu\\n", sizeof(arr) / sizeof(arr[0]));\r
\r
    return 0;\r
}`,d=`
  @keyframes fade-slide-up {
    0% { opacity: 0; transform: translateY(20px); }
    100% { opacity: 1; transform: translateY(0); }
  }
`,p=()=>{const a=new Date().getFullYear()-1998;return e.jsxs("div",{className:"dark",style:{backgroundColor:"#121212"},children:[" ",e.jsx("style",{children:d}),e.jsxs("div",{className:"max-w-4xl mx-auto p-6 space-y-8 bg-white dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300",children:[e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate",children:[e.jsx("h1",{className:"text-4xl font-light tracking-tight leading-tight",children:"Topic 1: Array memory model and contiguous memory concept"}),e.jsx("p",{className:"text-lg text-gray-600 dark:text-gray-400 mt-2 leading-relaxed",children:"How arrays are stored in memory ‚Äì one element right after another ‚Äì and why that matters for performance."})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[100ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üì¶ What does ‚Äúcontiguous‚Äù mean?"}),e.jsxs("p",{className:"leading-relaxed",children:["When you declare an array in C, the compiler reserves a block of memory large enough to hold all its elements. These elements are placed in ",e.jsx("strong",{children:"consecutive memory locations"})," ‚Äì that is, one after another without gaps. This layout is called ",e.jsx("em",{children:"contiguous memory allocation"}),"."]}),e.jsxs("p",{className:"leading-relaxed mt-4",children:["If you know the address of the first element (",e.jsx("code",{children:"&arr[0]"}),"), you can find the address of any other element by adding the index multiplied by the size of each element. This is why array access is so fast: ",e.jsx("code",{children:"arr[i]"})," is just ",e.jsx("code",{children:"base_address + i * element_size"}),"."]}),e.jsxs("div",{className:"mt-6 p-4 bg-blue-50 dark:bg-blue-900/20 border-l-4 border-blue-500 rounded",children:[e.jsx("p",{className:"text-sm font-medium",children:"üè´ Real‚Äëworld analogy:"}),e.jsxs("p",{className:"text-sm mt-1",children:["Think of a row of lockers in the ",e.jsx("strong",{children:"Barrackpore CNAT"})," corridor. If locker #0 is at the start of the row, locker #1 is immediately next to it, locker #2 next to that, and so on. To find locker #5, you just walk past 5 lockers from the start ‚Äì you don't need a map."]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[200ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üß† Memory layout of an array"}),e.jsx("div",{className:"flex justify-center p-4 bg-gray-100 dark:bg-gray-800 rounded-xl transition-all duration-300 hover:shadow-xl",children:e.jsxs("svg",{width:"500",height:"180",viewBox:"0 0 500 180",className:"max-w-full h-auto",children:[[0,1,2,3,4].map(s=>{const t=8388128+s*4;return e.jsxs("g",{className:"transition-all duration-300 hover:opacity-80",children:[e.jsx("rect",{x:40+s*80,y:"30",width:"70",height:"60",fill:"none",stroke:"#3b82f6",strokeWidth:"2",rx:"4"}),e.jsx("text",{x:40+s*80+35,y:"65",textAnchor:"middle",fill:"currentColor",className:"text-sm font-mono",children:s===0?"89":s===1?"72":s===2?"94":s===3?"68":"77"}),e.jsxs("text",{x:40+s*80+35,y:"110",textAnchor:"middle",fill:"#6b7280",className:"text-xs font-mono",children:["0x",t.toString(16)]}),e.jsxs("text",{x:40+s*80+35,y:"130",textAnchor:"middle",fill:"#6b7280",className:"text-xs",children:["[index ",s,"]"]})]},s)}),e.jsx("line",{x1:"75",y1:"20",x2:"415",y2:"20",stroke:"#ef4444",strokeWidth:"2",strokeDasharray:"4 4"}),e.jsx("text",{x:"200",y:"15",fill:"#ef4444",className:"text-xs",children:"contiguous memory"})]})}),e.jsx("p",{className:"text-sm text-gray-600 dark:text-gray-400 mt-2 text-center",children:"Each element occupies its own memory address; addresses increase by the size of the data type (here 4 bytes for int)."})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[300ms] space-y-6",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üíª Exploring memory addresses in C"}),e.jsx(r,{title:"Example 1: Printing addresses of array elements",initialCode:i}),e.jsxs("p",{className:"text-sm text-gray-600 dark:text-gray-400 -mt-2",children:["Notice how the addresses are equally spaced ‚Äì the gap is exactly ",e.jsx("code",{children:"sizeof(int)"})," (usually 4 bytes)."]}),e.jsx(r,{title:"Example 2: Pointer arithmetic",initialCode:n}),e.jsx(r,{title:"Example 3: Array name as a pointer",initialCode:o})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[400ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"üí° Tips & Tricks (Professional habits)"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 leading-relaxed",children:[e.jsxs("li",{children:[e.jsxs("strong",{children:["Use ",e.jsx("code",{children:"%p"})," to print pointers"]})," ‚Äì it formats addresses in a readable way (usually hexadecimal). Cast to ",e.jsx("code",{children:"(void*)"})," to be safe."]}),e.jsxs("li",{children:[e.jsxs("strong",{children:["Remember that ",e.jsx("code",{children:"arr + i"})," is the same as ",e.jsx("code",{children:"&arr[i]"})]})," ‚Äì both give the address of the i‚Äëth element."]}),e.jsxs("li",{children:[e.jsxs("strong",{children:[e.jsx("code",{children:"sizeof(arr) / sizeof(arr[0])"})," works only in the scope where ",e.jsx("code",{children:"arr"})," was declared"]})," ‚Äì once passed to a function, it decays to a pointer and this trick fails."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Contiguous layout means cache‚Äëfriendly"})," ‚Äì iterating sequentially over an array is extremely fast because the CPU prefetches consecutive memory."]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[500ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"‚ö†Ô∏è Common Pitfalls (Beginner traps)"}),e.jsxs("div",{className:"space-y-3",children:[e.jsxs("div",{className:"p-3 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded",children:[e.jsx("p",{className:"font-medium",children:"Confusing pointer arithmetic with integer arithmetic"}),e.jsxs("p",{className:"text-sm",children:[e.jsx("code",{children:"arr + 1"})," increments by the size of the element, not by 1 byte. This is automatic, but beginners sometimes try to manually add bytes."]})]}),e.jsxs("div",{className:"p-3 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded",children:[e.jsx("p",{className:"font-medium",children:"Assuming arrays are stored with gaps"}),e.jsx("p",{className:"text-sm",children:"Some think elements might be separated by extra bytes ‚Äì but in C, arrays are strictly contiguous with no padding between elements."})]}),e.jsxs("div",{className:"p-3 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded",children:[e.jsxs("p",{className:"font-medium",children:["Misusing ",e.jsx("code",{children:"&arr"})," vs ",e.jsx("code",{children:"arr"})]}),e.jsxs("p",{className:"text-sm",children:[e.jsx("code",{children:"&arr"})," gives the address of the entire array (type ",e.jsx("code",{children:"int (*)[5]"}),"), while ",e.jsx("code",{children:"arr"})," decays to pointer to first element. Their values may be the same but types differ."]})]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[600ms]",children:[e.jsx("h2",{className:"text-2xl font-medium mb-4",children:"‚úÖ Best Practices (Write clean, safe code)"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[e.jsxs("li",{children:["Use array indexing ",e.jsx("code",{children:"arr[i]"})," for readability; use pointer arithmetic only when you need to manipulate pointers directly."]}),e.jsxs("li",{children:["When printing addresses, always cast to ",e.jsx("code",{children:"(void*)"})," to match ",e.jsx("code",{children:"%p"})," format specifier."]}),e.jsxs("li",{children:["If you need the number of elements in a function, pass the size as a separate parameter ‚Äì don't rely on ",e.jsx("code",{children:"sizeof"})," inside the function."]}),e.jsx("li",{children:"Document any pointer arithmetic with comments, as it can be less obvious than indexing."})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[700ms] p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded",children:[e.jsx("h2",{className:"text-xl font-medium mb-2",children:"üìã Mini Checklist ‚Äì What to remember"}),e.jsxs("ul",{className:"list-check list-inside space-y-1",children:[e.jsx("li",{children:"‚úîÔ∏è Array elements are stored contiguously in memory."}),e.jsxs("li",{children:["‚úîÔ∏è Address of ",e.jsx("code",{children:"arr[i]"})," = base address + i * element_size."]}),e.jsxs("li",{children:["‚úîÔ∏è ",e.jsx("code",{children:"arr + i"})," equals ",e.jsx("code",{children:"&arr[i]"}),"."]}),e.jsx("li",{children:"‚úîÔ∏è Pointer arithmetic automatically scales by element size."}),e.jsxs("li",{children:["‚úîÔ∏è Use ",e.jsx("code",{children:"%p"})," to print addresses."]})]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[800ms] p-4 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded",children:[e.jsx("h2",{className:"text-xl font-medium mb-2",children:"ü§î Hint ‚Äì Think like a programmer"}),e.jsxs("p",{className:"italic",children:["‚ÄúWhen you see ",e.jsx("code",{children:"arr[3]"}),", the computer translates it to ",e.jsx("code",{children:"*(arr + 3)"}),". Try writing both forms in your code ‚Äì they produce identical machine instructions.‚Äù"]}),e.jsxs("p",{className:"italic mt-2",children:["Observe carefully: In Example 2, why does ",e.jsx("code",{children:"ptr + 2"})," give the address of the third element, not the second? Because starting from ",e.jsx("code",{children:"ptr = &arr[0]"}),", adding 2 moves forward by 2 elements."]})]}),e.jsxs("section",{className:"animate-[fade-slide-up_0.6s_ease-out] motion-safe:animate animation-delay-[900ms] p-6 bg-purple-50 dark:bg-purple-900/20 border-l-4 border-purple-500 rounded transition-all duration-300 hover:shadow-lg",children:[e.jsx("h2",{className:"text-xl font-medium mb-2",children:"üßë‚Äçüè´ Teacher's Note ‚Äì Sukanta Hui"}),e.jsxs("div",{className:"space-y-2 text-sm",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Sukanta Hui"})," (email: ",e.jsx("a",{href:"mailto:sukantahui@codernaccotax.co.in",className:"underline",children:"sukantahui@codernaccotax.co.in"}),", mobile: 7003756860) has been teaching programming for ",e.jsxs("strong",{children:[a," years"]})," (since 1998). His expertise spans Programming Languages, RDBMS, Operating Systems, and Web Development."]}),e.jsxs("p",{className:"mt-2",children:["üí¨ ‚ÄúAt ",e.jsx("strong",{children:"Naihati CNAT"}),", I draw a long rectangle on the board and divide it into small boxes. I label the first box with address 1000, the next 1004, 1008, etc. Students immediately see the pattern ‚Äì ",e.jsx("em",{children:"the addresses jump by the size of the data type"}),". This visual sticks.‚Äù"]}),e.jsxs("p",{className:"mt-2",children:["üîç ",e.jsx("strong",{children:"Point to remember:"})," The array's name ",e.jsx("code",{children:"arr"})," is not a variable; you cannot do ",e.jsx("code",{children:"arr++"}),". It's a constant pointer to the first element. However, you can assign another pointer and increment that."]})]})]})]})]})};export{p as default};
