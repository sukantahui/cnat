import{j as e}from"./index-CG3iA-Ea.js";import{c as s}from"./clsx-B-dksMZM.js";import{E as i}from"./EditableCCodeBlock-CCvfD5dY.js";const t=`#include <stdio.h>\r
\r
// Recursive factorial ‚Äì elegant but risky for large n\r
long long factorial(int n) {\r
    if (n == 0) return 1;\r
    return n * factorial(n - 1);\r
}\r
\r
int main() {\r
    int n = 20; // try 100000 ‚Äì crash!\r
    printf("%d! = %lld\\n", n, factorial(n));\r
    return 0;\r
}`,r=`#include <stdio.h>\r
\r
// Iterative factorial ‚Äì safe, fast, constant stack\r
long long factorial(int n) {\r
    long long result = 1;\r
    for (int i = 1; i <= n; i++) {\r
        result *= i;\r
    }\r
    return result;\r
}\r
\r
int main() {\r
    int n = 20; // works for any n up to overflow limit\r
    printf("%d! = %lld\\n", n, factorial(n));\r
    return 0;\r
}`,n=`#include <stdio.h>\r
\r
// Naive recursive Fibonacci ‚Äì DO NOT USE for n > 40\r
int fib(int n) {\r
    if (n <= 1) return n;\r
    return fib(n - 1) + fib(n - 2);\r
}\r
\r
int main() {\r
    int n = 10; // try 50 ‚Äì you'll wait forever\r
    printf("fib(%d) = %d\\n", n, fib(n));\r
    return 0;\r
}`,o=`
  @keyframes fadeSlideUp {
    0% { opacity: 0; transform: translateY(12px); }
    100% { opacity: 1; transform: translateY(0); }
  }
  @keyframes shakeWarning {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-2px); }
    75% { transform: translateX(2px); }
  }
  @media (prefers-color-scheme: light) {
    .topic26-root {
      background-color: #ffffff;
      color: #111827;
    }
    .topic26-card {
      background-color: #f9fafb;
      border-color: #e5e7eb;
    }
  }
  @media (prefers-color-scheme: dark) {
    .topic26-root {
      background-color: #111827;
      color: #f3f4f6;
    }
    .topic26-card {
      background-color: #1f2937;
      border-color: #374151;
    }
  }
`,x=()=>{const a=new Date().getFullYear()-1998;return e.jsxs(e.Fragment,{children:[e.jsx("style",{children:o}),e.jsx("div",{className:s("topic26-root","min-h-screen w-full px-4 py-8 md:px-8 lg:px-16","transition-colors duration-300","font-sans leading-relaxed"),children:e.jsxs("div",{className:"mx-auto max-w-4xl space-y-12",children:[e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none"),children:[e.jsx("h1",{className:"mb-4 text-4xl font-extrabold tracking-tight text-indigo-400 dark:text-indigo-400",children:"‚ö†Ô∏è When to Avoid Recursion"}),e.jsxs("p",{className:"text-xl text-gray-300 dark:text-gray-300",children:["Recursion is elegant, but it's not a silver bullet. In many situations, recursion can lead to crashes, poor performance, or unnecessarily complex code. Knowing when ",e.jsx("em",{children:"not"})," to use recursion is as important as knowing how to use it."]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.1s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-indigo-300",children:"üìå When Recursion Fails"}),e.jsxs("div",{className:"grid gap-6 md:grid-cols-2",children:[e.jsxs("div",{className:"topic26-card rounded-xl border p-6 transition-all duration-300 hover:scale-[1.02] hover:shadow-lg",children:[e.jsxs("ul",{className:"list-disc space-y-3 pl-5",children:[e.jsxs("li",{children:[e.jsx("strong",{className:"text-amber-300",children:"Deep recursion:"})," If the recursion depth can exceed the stack limit (typically a few thousand calls), stack overflow will crash the program."]}),e.jsxs("li",{children:[e.jsx("strong",{className:"text-amber-300",children:"Performance‚Äëcritical code:"})," ","Function call overhead and lack of tail‚Äëcall optimization in C make recursion slower than iteration."]}),e.jsxs("li",{children:[e.jsx("strong",{className:"text-amber-300",children:"Problems with exponential complexity:"})," ","Some recursive solutions (e.g., naive Fibonacci) recompute the same values many times, making them impractical."]}),e.jsxs("li",{children:[e.jsx("strong",{className:"text-amber-300",children:"Naturally iterative problems:"})," ","Simple loops (e.g., iterating over an array) are clearer and safer when written iteratively."]}),e.jsxs("li",{children:[e.jsx("strong",{className:"text-amber-300",children:"Limited stack size environments:"})," ","In embedded systems or kernels, stack space is precious ‚Äì recursion is often banned."]})]}),e.jsxs("p",{className:"mt-4 text-sm italic text-gray-400",children:["üîç ",e.jsx("strong",{children:"Observe:"})," Each of these cases suggests that an iterative solution would be more reliable."]})]}),e.jsx("div",{className:s("topic26-card flex items-center justify-center rounded-xl border p-4","transition-all duration-300 hover:scale-[1.02] hover:shadow-lg"),children:e.jsxs("svg",{width:"300",height:"200",viewBox:"0 0 300 200",className:"w-full max-w-xs",children:[e.jsx("rect",{x:"20",y:"30",width:"100",height:"150",fill:"none",stroke:"#4b5563",strokeWidth:"2",strokeDasharray:"4 3"}),e.jsx("text",{x:"70",y:"20",fill:"#9ca3af",fontSize:"10",textAnchor:"middle",children:"Recursion"}),e.jsx("rect",{x:"30",y:"160",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"140",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"120",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"100",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"80",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"60",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"40",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("rect",{x:"30",y:"20",width:"80",height:"15",rx:"2",fill:"#1f2937",stroke:"#6b7280"}),e.jsx("text",{x:"70",y:"185",fill:"#f87171",fontSize:"9",textAnchor:"middle",children:"overflow!"}),e.jsx("line",{x1:"110",y1:"20",x2:"130",y2:"20",stroke:"#f87171",strokeWidth:"3"}),e.jsx("rect",{x:"180",y:"30",width:"100",height:"150",fill:"none",stroke:"#4b5563",strokeWidth:"2",strokeDasharray:"4 3"}),e.jsx("text",{x:"230",y:"20",fill:"#9ca3af",fontSize:"10",textAnchor:"middle",children:"Iteration"}),e.jsx("circle",{cx:"230",cy:"60",r:"8",fill:"#10b981",fillOpacity:"0.3",stroke:"#10b981",strokeWidth:"1.5",children:e.jsx("animate",{attributeName:"cy",values:"60;120;60",dur:"3s",repeatCount:"indefinite"})}),e.jsx("text",{x:"230",cy:"45",fill:"#10b981",fontSize:"9",textAnchor:"middle",children:"loop"})]})})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.2s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-indigo-300",children:"üìå Danger: Deep Recursion"}),e.jsxs("div",{className:"topic26-card rounded-xl border p-6 transition-all duration-300 hover:shadow-lg",children:[e.jsx("p",{className:"mb-3",children:"Each recursive call consumes stack memory. The stack size is limited (typically 1‚Äì8 MB). For a function that uses ~50 bytes per frame, 100,000 calls would need 5 MB ‚Äì likely to overflow."}),e.jsxs("p",{className:"mb-3",children:[e.jsx("strong",{children:"Example:"})," A recursive function to sum 1..n might work for n=1000 but crash for n=100000."]}),e.jsxs("pre",{className:"rounded bg-gray-800 p-2 text-sm",children:[e.jsx("span",{className:"text-gray-400",children:"// May overflow for large n"}),e.jsx("br",{}),e.jsx("span",{className:"text-purple-400",children:"int"})," sum(",e.jsx("span",{className:"text-emerald-300",children:"int n"}),") ","{",e.jsx("br",{}),"¬†¬†",e.jsx("span",{className:"text-purple-400",children:"if"})," (n == 0) ",e.jsx("span",{className:"text-purple-400",children:"return"})," 0;",e.jsx("br",{}),"¬†¬†",e.jsx("span",{className:"text-purple-400",children:"return"})," n + sum(n - 1);",e.jsx("br",{}),"}"]}),e.jsxs("p",{className:"mt-3 text-sm italic text-gray-400",children:["üîç ",e.jsx("strong",{children:"Observe:"})," The iterative version uses O(1) stack."]})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.3s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-indigo-300",children:"üìå Performance Overhead"}),e.jsxs("div",{className:"topic26-card rounded-xl border p-6",children:[e.jsx("p",{children:"Function calls have overhead: pushing parameters, saving registers, jumping, returning. A loop avoids all that. In performance‚Äëcritical code, even a few microseconds per call can add up."}),e.jsx("p",{className:"mt-2",children:"Additionally, C does not guarantee tail‚Äëcall optimization, so even tail‚Äërecursive functions (where the recursive call is the last operation) may still use stack frames."})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.4s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-indigo-300",children:"üìå Exponential Recursion: Fibonacci"}),e.jsxs("div",{className:"topic26-card rounded-xl border p-6",children:[e.jsx("p",{className:"mb-3",children:"The naive recursive Fibonacci function has O(2‚Åø) time complexity. Computing fib(40) calls the function billions of times."}),e.jsxs("pre",{className:"rounded bg-gray-800 p-2 text-sm",children:[e.jsx("span",{className:"text-purple-400",children:"int"})," fib(",e.jsx("span",{className:"text-emerald-300",children:"int n"}),") ","{",e.jsx("br",{}),"¬†¬†",e.jsx("span",{className:"text-purple-400",children:"if"})," (n <= 1) ",e.jsx("span",{className:"text-purple-400",children:"return"})," n;",e.jsx("br",{}),"¬†¬†",e.jsx("span",{className:"text-purple-400",children:"return"})," fib(n-1) + fib(n-2);",e.jsx("br",{}),"}"]}),e.jsxs("p",{className:"mt-3",children:["This is a classic case where recursion ",e.jsx("em",{children:"must"})," be avoided. Iterative or memoized solutions are far better."]})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.5s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-indigo-300",children:"üíª Live Code: Recursion vs Iteration"}),e.jsx(i,{title:"Example 1: Recursive factorial (elegant but risky for large n)",initialCode:t}),e.jsx(i,{title:"Example 2: Iterative factorial (safe, fast, no stack growth)",initialCode:r}),e.jsx(i,{title:"Example 3: Naive Fibonacci ‚Äì DO NOT USE for large n!",initialCode:n}),e.jsxs("div",{className:"mt-2 rounded-lg bg-indigo-900/30 p-4 italic",children:[e.jsx("strong",{children:"üîç Observe:"})," For factorial, the recursive version is short, but for n=100000 it will overflow. The iterative version handles any n (within integer range). For Fibonacci, avoid the recursive version entirely."]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.6s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-indigo-300",children:"üè´ Lessons Learned at Barrackpore & Naihati CNAT"}),e.jsxs("div",{className:"topic26-card rounded-xl border p-6 transition-all duration-300 hover:shadow-lg",children:[e.jsxs("p",{className:"mb-4",children:["At ",e.jsx("strong",{children:"Barrackpore CNAT"}),", ",e.jsx("strong",{children:"Tuhina"})," wrote a recursive function to compute the sum of the first n numbers. It worked perfectly for n=100. For n=1,000,000, the program crashed mysteriously. She learned about stack overflow the hard way."]}),e.jsxs("p",{className:"mb-4",children:["At ",e.jsx("strong",{children:"Naihati CNAT"}),", ",e.jsx("strong",{children:"Debangshu"})," proudly showed his recursive Fibonacci function for n=50 ‚Äì it didn't finish after 5 minutes. He then wrote an iterative version that ran in microseconds."]}),e.jsxs("p",{className:"text-sm italic text-gray-400",children:["üßë‚Äçüéì Students like ",e.jsx("strong",{children:"Swadeep, Abhronila, Ritaja"})," now always consider the depth and complexity before choosing recursion."]})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.7s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-amber-400",children:"‚ö†Ô∏è Common Pitfalls ‚Äì Beginners Edition"}),e.jsxs("div",{className:"topic26-card rounded-xl border border-amber-700/50 bg-amber-900/20 p-6",children:[e.jsxs("ul",{className:"list-disc space-y-3 pl-5",children:[e.jsxs("li",{children:[e.jsx("span",{className:"font-bold text-amber-300",children:"Assuming recursion is always elegant:"})," ","Not every problem benefits from recursion. Overuse leads to unreadable and fragile code."]}),e.jsxs("li",{children:[e.jsx("span",{className:"font-bold text-amber-300",children:"Ignoring stack limits:"})," ","Not realising that even correct recursion can overflow with large inputs."]}),e.jsxs("li",{children:[e.jsx("span",{className:"font-bold text-amber-300",children:"Using recursion for simple loops:"})," ","Writing ",e.jsx("code",{children:"printNumbers(n)"})," recursively when a for loop is simpler and safer."]}),e.jsxs("li",{children:[e.jsx("span",{className:"font-bold text-amber-300",children:"Not benchmarking:"})," ","Assuming the recursive version is fast enough without testing."]}),e.jsxs("li",{children:[e.jsx("span",{className:"font-bold text-amber-300",children:"Believing in tail‚Äëcall optimization:"})," ","In C, it's not guaranteed ‚Äì don't rely on it."]})]}),e.jsxs("p",{className:"mt-4 text-sm",children:["üîé ",e.jsx("strong",{children:"Think about‚Ä¶"})," How would you estimate the maximum safe recursion depth on your system?"]})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.8s]","space-y-6"),children:[e.jsx("h2",{className:"text-2xl font-semibold text-emerald-400",children:"üßº Best Practices ‚Äì Professional Habits"}),e.jsxs("div",{className:"grid gap-5 md:grid-cols-2",children:[e.jsxs("div",{className:"topic26-card rounded-xl border p-5",children:[e.jsx("h3",{className:"mb-2 font-bold text-emerald-300",children:"üìè Estimate depth first"}),e.jsx("p",{className:"text-sm",children:"If recursion depth could exceed a few thousand, use iteration."})]}),e.jsxs("div",{className:"topic26-card rounded-xl border p-5",children:[e.jsx("h3",{className:"mb-2 font-bold text-emerald-300",children:"‚ö° Profile both versions"}),e.jsx("p",{className:"text-sm",children:"When performance matters, measure recursive vs iterative."})]}),e.jsxs("div",{className:"topic26-card rounded-xl border p-5",children:[e.jsx("h3",{className:"mb-2 font-bold text-emerald-300",children:"üß† Use memoization for recursion"}),e.jsx("p",{className:"text-sm",children:"For problems like Fibonacci, caching results can salvage recursion."})]}),e.jsxs("div",{className:"topic26-card rounded-xl border p-5",children:[e.jsx("h3",{className:"mb-2 font-bold text-emerald-300",children:"üìö Know your stack size"}),e.jsxs("p",{className:"text-sm",children:["On Unix, ",e.jsx("code",{children:"ulimit -s"})," shows stack size. Use it to gauge safety."]})]})]})]}),e.jsxs("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:0.9s]","rounded-xl border border-indigo-700 bg-indigo-900/20 p-6"),children:[e.jsx("h2",{className:"mb-4 text-2xl font-semibold text-indigo-300",children:"üìã Mini Checklist ‚Äì Topic 26"}),e.jsxs("ul",{className:"grid gap-3 sm:grid-cols-2",children:[e.jsxs("li",{className:"flex items-start gap-2",children:[e.jsx("span",{className:"text-indigo-400",children:"‚úÖ"})," I can identify when recursion might cause stack overflow."]}),e.jsxs("li",{className:"flex items-start gap-2",children:[e.jsx("span",{className:"text-indigo-400",children:"‚úÖ"})," I understand the performance overhead of function calls."]}),e.jsxs("li",{className:"flex items-start gap-2",children:[e.jsx("span",{className:"text-indigo-400",children:"‚úÖ"})," I know why naive Fibonacci is a bad use of recursion."]}),e.jsxs("li",{className:"flex items-start gap-2",children:[e.jsx("span",{className:"text-indigo-400",children:"‚úÖ"})," I can choose iteration over recursion when appropriate."]}),e.jsxs("li",{className:"flex items-start gap-2",children:[e.jsx("span",{className:"text-indigo-400",children:"‚úÖ"})," I never assume tail‚Äëcall optimization in C."]})]})]}),e.jsx("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:1.0s]","topic26-card rounded-xl border border-indigo-500/50 bg-indigo-950/30 p-6","transition-all duration-300 hover:scale-[1.01] hover:border-indigo-400 hover:shadow-2xl"),children:e.jsxs("div",{className:"flex items-start gap-4",children:[e.jsx("div",{className:"text-4xl",children:"üßë‚Äçüè´"}),e.jsxs("div",{className:"flex-1",children:[e.jsx("h2",{className:"mb-2 text-2xl font-semibold text-indigo-300",children:"Teacher‚Äôs Note"}),e.jsx("p",{className:"mb-2 font-medium text-indigo-200",children:"Sukanta Hui ‚Äî Mentor, C Programming"}),e.jsxs("p",{className:"mb-2 text-sm",children:["üìß sukantahui@codernaccotax.co.in ¬†|¬† üì± 7003756860 ¬†|¬† üíª ",a," years (since 1998)"]}),e.jsxs("p",{className:"text-gray-300",children:["‚ÄúI've seen students fall in love with recursion and try to use it everywhere ‚Äì including places it doesn't belong. At"," ",e.jsx("strong",{children:"Barrackpore CNAT"})," and ",e.jsx("strong",{children:"Naihati CNAT"}),", I remind them: recursion is a tool, not a religion. If it crashes or crawls, switch to iteration. ",e.jsx("br",{}),e.jsx("span",{className:"mt-2 block italic",children:"üí° Professional tip: When you write a recursive function, always ask yourself: ‚ÄòCould this be written as a simple loop?‚Äô If yes, and depth is a concern, write the loop."})]})]})]})}),e.jsx("section",{className:s("motion-safe:animate-[fadeSlideUp_0.6s_ease-out]","motion-reduce:animate-none","[animation-delay:1.1s]","rounded-xl border border-gray-700 bg-gray-800/50 p-5 text-sm"),children:e.jsxs("div",{className:"flex items-start gap-3",children:[e.jsx("span",{className:"text-2xl",children:"üí≠"}),e.jsxs("div",{children:[e.jsx("strong",{className:"text-indigo-300",children:"Hint ‚Äì try changing this:"})," ","In the recursive factorial example, try computing factorial of 100000. What happens? (Don't actually run it if you value your IDE's stability!) Then try the iterative version. Why does one crash and the other not?",e.jsx("br",{}),e.jsx("span",{className:"mt-2 block text-gray-400",children:"(The recursive version exhausts stack; the iterative uses constant stack.)"})]})]})}),e.jsx("div",{className:"pt-6 text-center text-xs text-gray-500",children:"Topic 26 complete ‚Äì you now know when to avoid recursion. Next: header files ‚Äì purpose and structure."})]})})]})};export{x as default};
